<!DOCTYPE html>
<html lang="ml">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Mind Map ‚Äî Added Features</title>
<style>
  :root{--toolbar-h:48px}
  html,body{height:100%;margin:0;font-family:Segoe UI, Arial, sans-serif}
  #toolbar{
    height:var(--toolbar-h);
    background:#f3f3f3;border-bottom:1px solid #ddd;
    display:flex;align-items:center;gap:8px;padding:6px 10px;box-sizing:border-box;
  }
  #toolbar button, #toolbar input[type=file] { padding:8px 12px; border-radius:6px; border:1px solid #bbb; background:#fff; cursor:pointer; }
  #app {
    position: fixed;
    top: var(--toolbar-h);
    left: 0;
    right: 0;
    bottom: 0;
    overflow: hidden;
    background: #333333;
    cursor: grab;
  }
  svg#edges {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 5;
    pointer-events: auto; /* ‚úÖ Edges clickable */
  }
  .edge-line{
    stroke-width: 7px; /* ‚úÖ Large hit area */
    stroke-linecap: round;
    cursor: pointer;
    pointer-events: auto; /* ‚úÖ Entire line clickable */
    fill: none;
  }
  .edge-line.child { stroke:#2c7be5; }
  .edge-line.sibling { stroke:#3ebd3e; }
  .edge-line.selected{ 
    stroke:#ff8c00; 
    stroke-width:9px;
    filter: drop-shadow(0 0 1px rgba(0,0,0,.2)); 
  }

  #canvas{     
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;       
    height: 100%;      
    transform-origin: left top;
    z-index: 10;
    pointer-events: none; /* ‚úÖ Critical: clicks pass through to SVG */
  }

  .node {
    position:absolute;
    display:inline-block;
    min-width:90px;
    min-height:36px;
    max-width:280px;
    padding:8px 12px;
    border-radius:10px;
    border:2px solid #2c7be5; background:#fff; box-shadow:0 2px 6px rgba(0,0,0,0.08);
    user-select:none; 
    cursor:pointer; 
    transform-origin: left top;
    word-break:break-word;
    transition:width 0.12s, height 0.12s, border-radius .15s;
    box-sizing:border-box;
    pointer-events: auto; /* ‚úÖ Nodes clickable */
  }
  .node.central { background:#fff7e6; border-color:#ffaa00; }
  .node.child   { background:#e6f7ff; border-color:#2c7be5; }
  .node.sibling { background:#e6ffe6; border-color:#3ebd3e; }
  
  .node .title{ font-weight:600; line-height:1.35; }
  .node .connector {
    position:absolute; width:12px; height:12px; right:-8px; top:50%;
    transform:translateY(-50%); background:#2c7be5; border-radius:50%; cursor:crosshair;
    border:2px solid #fff; box-sizing:border-box;
  }
  .node.selected { box-shadow:0 0 0 4px rgba(231,76,60,0.25); border-color:#e74c3c; }

  /* Inspector (movable + minimizable) */
  #inspector {
    position:fixed; top:80px; right:12px; width:260px; background:#cfcece; border:1px solid #ddd; padding:8px;
    box-sizing:border-box; border-radius:8px; z-index:1200; box-shadow:0 6px 20px rgba(0,0,0,0.08);
  }
  #inspector-header{ display:flex; align-items:center; justify-content:space-between; cursor:move; user-select:none; padding:4px 2px;}
  #inspector-body{ padding-top:6px; }
  #inspector.minimized{ height:36px; overflow:hidden; width:200px; }
  #inspector .btns { display:flex; gap:6px; align-items:center; }
  #inspector label{ display:block; font-size:13px; margin-top:8px }
  #inspector input[type="color"], #inspector input[type="number"]{ width:100%; padding:6px; box-sizing:border-box; }

  .small { font-size:12px;color:#555; }

  /* --- Node Text Editor Modal (New Ribbon Style) --- */
  #editorModal {
    display: none;
    position: fixed;
    inset: 0;
    background: rgba(0, 0, 0, 0.25);
    z-index: 999;
    align-items: center;
    justify-content: center;
  }
  #editorBox {
    width: 940px;
    max-width: 90vw;
    background: #f0f0f0;
    border: 2px solid #ccc;
    border-radius: 8px;
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.25);
    display: flex;
    flex-direction: column;
    overflow: hidden;
  }
  #editorTitleBar {
    background: #ddd;
    padding: 6px 12px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    border-bottom: 1px solid #aaa;
  }
  #editorTitleBar h3 {
    margin: 0;
    font-size: 14px;
    font-weight: bold;
  }
  #editorCloseBtn {
    background: none;
    border: none;
    font-size: 18px;
    cursor: pointer;
    padding: 0 6px;
  }
  #editorTabs {
    background: #eee;
    padding: 4px 8px;
    display: flex;
    border-bottom: 1px solid #ccc;
  }
  .editorTab {
    padding: 4px 12px;
    cursor: pointer;
    border: 1px solid transparent;
    border-bottom: none;
    background: #eee;
    font-weight: bold;
  }
  .editorTab.active {
    background: #fff;
    border-color: #ccc;
    border-bottom: 1px solid #fff;
  }
  #editorToolbarHome, #editorToolbarInsert {
    display: none;
    padding: 4px 8px;
    background: #eee;
    border-bottom: 1px solid #ccc;
    flex-wrap: wrap;
    gap: 4px;
  }
  #editorToolbarHome.active, #editorToolbarInsert.active {
    display: flex;
  }
  .editorToolbarButton {
    border: 1px solid #bbb !important;
    border-radius: 3px !important;
    background: #fff !important;
    padding: 3px 6px !important;
    min-width: 28px;
    cursor: pointer;
    font-size: 12px;
  }
  .editorToolbarButton:hover {
    background: #eaf3ff !important;
    border-color: #4a90e2 !important;
  }
  .editorToolbarSelect {
    border: 1px solid #bbb !important;
    border-radius: 3px !important;
    background: #fff !important;
    padding: 3px 6px !important;
    min-width: 80px;
    cursor: pointer;
    font-size: 12px;
  }
  .editorToolbarGroup {
    display: flex;
    gap: 4px;
    align-items: center;
    border-right: 2px solid #787878;
    padding-right: 8px;
  }
  .editorToolbarGroup:last-child {
    border-right: none;
    padding-right: 0;
  }
  #editorContent {
    flex-grow: 1;
    padding: 10px;
    background: Red;
    overflow-y: auto;
    min-height: 200px;
  }
  #editorSaveBtn {
    background: #ddd;
    border: 1px solid #ccc;
    padding: 8px 16px;
    margin: 8px;
    align-self: flex-end;
    cursor: pointer;
    font-weight: bold;
  }
  #editorSaveBtn:hover {
    background: #ccc;
  }

  /* Quill editor-‡¥ø‡¥≤‡µÅ‡¥Ç Node content-‡¥ø‡¥≤‡µÅ‡¥Ç ‡¥â‡¥≥‡µç‡¥≥ images fit ‡¥Ü‡¥ï‡µç‡¥ï‡¥æ‡µª */
  .ql-editor img,
  .node .title img {
    max-width: 100%;
    height: auto;
    display: block;
  }

  /* iframe support for videos */
  .ql-editor iframe,
  .node .title iframe {
    max-width: 100%;
    height: auto;
    border: none;
    display: block;
    margin: 8px 0;
  }

  .node img {
    pointer-events: none;       /* mouse events ignore ‡¥ö‡µÜ‡¥Ø‡µç‡¥Ø‡¥æ‡µª */
    user-drag: none;            /* dragging disable */
    -webkit-user-drag: none;    /* Safari/Chrome support */
  }

  /* === Quill Editor Background Fix === */
  #editorBox {
    background: blue;
  }
  .ql-editor {
    background: green !important;
  }

  /* Hide default Quill toolbar */
  .ql-toolbar {
    display: none !important;
  }

</style>

<!-- Quill -->
<link href="https://cdn.quilljs.com/1.3.7/quill.snow.css" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Noto+Sans+Malayalam&display=swap" rel="stylesheet">
<script src="https://cdn.quilljs.com/1.3.7/quill.min.js"></script>

</head>
<body>

<div id="toolbar">
  <button id="btnAddChild">+ Child</button>
  <button id="btnAddSibling">+ Sibling</button>
  <button id="btnDelete">- Delete</button>
  <button id="btnSave">Save</button>
  <input id="fileImport" type="file" accept="application/json">
  <label for="canvasBgColor" style="margin-left:1px; margin-right:4px;font-family: Segoe UI, Arial, sans-serif; font-size: 12px;">BG Color:</label>
  <input type="color" id="canvasBgColor" value="#333333" title="Change Canvas Background">

  <!-- üî• ‡¥™‡µÅ‡¥§‡¥ø‡¥Ø Inspector button ‡¥á‡¥µ‡¥ø‡¥ü‡µÜ ‡¥ö‡µá‡µº‡¥ï‡µç‡¥ï‡µÅ‡¥ï -->
  <button id="btnToggleInspector">Inspector</button>
  <div class="small" style="margin-left:8px;color:#333">Zoom: mousewheel ‚Ä¢ Pan: drag background ‚Ä¢ New node: Ctrl/Cmd+Click ‚Ä¢ Connect: drag the blue dot ‚Ä¢ Delete works for node/edge</div>
</div>

<div id="app">
  <svg id="edges"></svg>
  <div id="canvas"></div>
</div>

<!-- Movable, Minimizable Inspector -->
<div id="inspector">
  <div id="inspector-header">
    <strong>Inspector</strong>
    <div class="btns">
      <button id="inspector-min-btn" title="Minimize">_</button>
      <button id="inspector-close-btn" title="Close">‚úï</button>
    </div>
  </div>
  <div id="inspector-body">
    <label>Background</label>
    <input id="inBg" type="color" value="#ffffff">
    <label>Border</label>
    <input id="inBorder" type="color" value="#2c7be5">
    <label>Font size</label>
    <input id="inSize" type="number" min="10" max="36" value="14" style="width:80px">
    <div style="margin-top:10px">
      <button id="btnApply">Apply</button>
    </div>
  </div>
</div>

<!-- Node Text Editor Modal (New Ribbon Style) -->
<div id="editorModal">
  <div id="editorBox">
    <div id="editorTitleBar">
      <h3>Node Text Editor</h3>
      <button id="editorCloseBtn">√ó</button>
    </div>
    <div id="editorTabs">
      <div class="editorTab active" data-tab="home">Home</div>
      <div class="editorTab" data-tab="insert">Insert</div>
    </div>
    <div id="editorToolbarHome" class="active">
      <div class="editorToolbarGroup">
        <select class="editorToolbarSelect ql-font" id="fontFamily">
          <option value="Calibri">Calibri (Body)</option>
          <option value="Arial">Arial</option>
          <option value="Times New Roman">Times New Roman</option>
          <option value="Verdana">Verdana</option>
        </select>
        <select class="editorToolbarSelect ql-size" id="fontSize">
          <option value="11">11</option>
          <option value="12">12</option>
          <option value="14">14</option>
          <option value="16">16</option>
          <option value="18">18</option>
          <option value="20">20</option>
        </select>
      </div>
      <div class="editorToolbarGroup">
        <button class="editorToolbarButton ql-bold" title="Bold">B</button>
        <button class="editorToolbarButton ql-italic" title="Italic">I</button>
        <button class="editorToolbarButton ql-underline" title="Underline">U</button>
        <button class="editorToolbarButton ql-strike" title="Strikethrough">abc</button>
      </div>
      <div class="editorToolbarGroup">
        <button class="editorToolbarButton ql-script" value="sub" title="Subscript">x‚ÇÇ</button>
        <button class="editorToolbarButton ql-script" value="super" title="Superscript">x¬≤</button>
      </div>
      <div class="editorToolbarGroup">
        <button class="editorToolbarButton ql-color" title="Text Color">A</button>
        <button class="editorToolbarButton ql-background" title="Highlight Color">A</button>
      </div>
      <div class="editorToolbarGroup">
        <button class="editorToolbarButton ql-align" value="" title="Align Left">{=</button>
        <button class="editorToolbarButton ql-align" value="center" title="Align Center">=</button>
        <button class="editorToolbarButton ql-align" value="right" title="Align Right">=}</button>
        <button class="editorToolbarButton ql-align" value="justify" title="Justify">{=}</button>
      </div>
      <div class="editorToolbarGroup">
        <button class="editorToolbarButton ql-list" value="ordered" title="Ordered List">1=</button>
        <button class="editorToolbarButton ql-list" value="bullet" title="Bullet List">‚ñ™=</button>
        <button class="editorToolbarButton ql-indent" value="-1" title="Decrease Indent">‚Üê</button>
        <button class="editorToolbarButton ql-indent" value="+1" title="Increase Indent">‚Üí</button>
      </div>
      <div class="editorToolbarGroup">
        <button class="editorToolbarButton ql-clean" title="Clear Formatting">‚ôªÔ∏è</button>
      </div>
    </div>
    <div id="editorToolbarInsert">
      <div class="editorToolbarGroup">
        <button class="editorToolbarButton" id="insertPicture" title="Pictures">üñº</button>
        <button class="editorToolbarButton" id="insertShapes" title="Shapes">üî∑</button>
        <button class="editorToolbarButton" id="insertIcons" title="Icons">‚≠ê</button>
        <button class="editorToolbarButton" id="insertTable" title="Table">üìä</button>
        <button class="editorToolbarButton" id="insertVideo" title="Online Video Media">üé¨</button>
      </div>
    </div>
    <div id="editorContent">
      <div id="editor"></div>
    </div>
    <button id="editorSaveBtn">Save</button>
  </div>
</div>

<script>
/* ============================
   Mind Map App ‚Äî Full Code
   ============================ */

/* ===== GLOBAL ELEMENTS ===== */
const canvas = document.getElementById('canvas');
const edgesSVG = document.getElementById('edges');
const btnAddChild = document.getElementById('btnAddChild');
const btnAddSibling = document.getElementById('btnAddSibling');
const btnDelete = document.getElementById('btnDelete');
const btnExport = document.getElementById('btnExport');
const fileImport = document.getElementById('fileImport');
const app = document.getElementById('app');
const canvasBgInput = document.getElementById('canvasBgColor');
canvasBgInput.addEventListener('input', (e)=>{
  app.style.background = e.target.value;// user select ‡¥ö‡µÜ‡¥Ø‡µç‡¥§ background instantly update
}); 


/* application state */
let nodes = [];            // DOM elements for nodes
let edges = [];            // objects {line, fromEl, toEl, edgeType}
let selectedNode = null;   // currently selected node DOM
let selectedEdge = null;   // currently selected svg line DOM

/* drag state */
let draggingNode = null;
let dragOffset = {x:0,y:0}; // pointer offset in canvas-local coords

/* pan & zoom */
let scale = 1, panX = 0, panY = 0;

/* ============================
   Utility functions
   ============================ */

/* escapeHtml
   ‚Äî ‡¥í‡¥∞‡µÅ string HTML ‡¥Ü‡¥Ø‡¥ø ‡¥∏‡µÜ‡¥±‡µç‡¥±‡µç ‡¥ö‡µÜ‡¥Ø‡µç‡¥Ø‡µÅ‡¥Æ‡µç‡¥™‡µã‡µæ ‡¥∏‡µÅ‡¥∞‡¥ï‡µç‡¥∑‡¥ø‡¥§‡¥Æ‡¥æ‡¥ï‡µç‡¥ï‡¥æ‡µª ‡¥â‡¥™‡¥Ø‡µã‡¥ó‡¥ø‡¥ï‡µç‡¥ï‡µÅ‡¥®‡µç‡¥®‡¥§‡µç */
function escapeHtml(s){
  return String(s || '')
    .replace(/&/g,'&amp;').replace(/</g,'<').replace(/>/g,'>');
}

/* rgbToHex
   ‚Äî computed style ‡¥µ‡¥®‡µç‡¥® rgb() ‡¥Æ‡µÇ‡¥≤‡µç‡¥Ø‡¥Ç hex-‡¥≤‡µá‡¥ï‡µç‡¥ï‡µç ‡¥Æ‡¥æ‡¥±‡µç‡¥±‡¥æ‡µª */
function rgbToHex(v){
  if(!v) return '#ffffff';
  if(v.startsWith('#')) return v;
  const m = v.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/);
  if(!m) return '#ffffff';
  return '#'+[1,2,3].map(i=>Number(m[i]).toString(16).padStart(2,'0')).join('');
}

/* autoResizeNode
   ‚Äî node content update ‡¥ï‡¥¥‡¥ø‡¥û‡µç‡¥û‡µº automatic sizing ‡¥ö‡µÜ‡¥Ø‡µç‡¥Ø‡¥æ‡µª */
function autoResizeNode(n){
  n.style.width = 'auto';
  n.style.height = 'auto';
  n.style.maxWidth = '280px';
  n.style.minWidth = '90px';
  n.style.minHeight = '36px';
}

/* setTransform
   ‚Äî pan & zoom ‡¥®‡¥ø‡¥≤‡¥µ‡¥ø‡¥≤‡µÅ‡¥≥‡µç‡¥≥ canvas-transform ‡¥í‡¥±‡µç‡¥±‡¥∏‡µç‡¥•‡¥æ‡¥®‡¥§‡µç‡¥§‡µç ‡¥é‡¥ü‡µÅ‡¥ï‡µç‡¥ï‡¥æ‡µª */
function setTransform(){
  canvas.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
  updateEdges();
}

/* ============================
   Node creation / selection
   ============================ */

/* mkNode(x,y,html,type)
   ‚Äî ‡¥™‡µÅ‡¥§‡¥ø‡¥Ø node ‡¥∏‡µÉ‡¥∑‡µç‡¥ü‡¥ø‡¥ï‡µç‡¥ï‡µÅ‡¥®‡µç‡¥®‡µÅ.
   ‚Äî type ‡¥∏‡¥ú‡µç‡¥ú‡¥Æ‡¥æ‡¥ï‡µç‡¥ï‡¥ø‡¥Ø‡¥æ‡µΩ (child/sibling/central) ‡¥Ö‡¥§‡¥ø‡¥®‡¥®‡µÅ‡¥∏‡¥∞‡¥ø‡¥ö‡µç‡¥ö‡µç default color-border apply ‡¥ö‡µÜ‡¥Ø‡µç‡¥Ø‡µÅ‡¥Ç.
   ‚Äî central node ‡¥Ü‡¥¶‡µç‡¥Ønode ‡¥Ü‡¥ï‡µÅ‡¥Ç (non-deletable). */
function mkNode(x, y, html='Node', type='child'){
  const n = document.createElement('div');
  n.className = 'node ' + (type || 'child');
  n._type = type || 'child';
  n.style.left = x + 'px';
  n.style.top  = y + 'px';
  n.classList.remove('right-shape');
  // default styling by type
  if(type==='central'){ n.style.background = '#fff7e6'; n.style.borderColor = '#ffaa00'; n.dataset.nonremovable = 'true'; }
  else if(type==='child'){ n.style.background = '#e6f7ff'; n.style.borderColor = '#2c7be5'; }
  else if(type==='sibling'){ n.style.background = '#e6ffe6'; n.style.borderColor = '#3ebd3e'; }
  n.style.fontSize = '14px';
  n.innerHTML = `
  <div class="title">${html}</div>
  <div class="timestamp small" style="margin-top:4px;color:#777;font-size:11px"></div>
  <div class="connector" title="drag to connect"></div>
`;

  autoResizeNode(n);
  canvas.appendChild(n);
  nodes.push(n);

  /* click select */
  n.addEventListener('click', e=>{
    e.stopPropagation(); // ‚úÖ Prevent click from reaching canvas/SVG
    selectNode(n);
  });

  /* pointerdown for dragging node (no clamping) */
  n.addEventListener('pointerdown', e=>{
    if(e.target.classList.contains('connector')) return; // connector handled separately
    const appRect = app.getBoundingClientRect();
    const pointerCanvasX = (e.clientX - appRect.left - panX)/scale;
    const pointerCanvasY = (e.clientY - appRect.top  - panY)/scale;
    dragOffset.x = pointerCanvasX - n.offsetLeft;
    dragOffset.y = pointerCanvasY - n.offsetTop;
    draggingNode = n;
    n.setPointerCapture(e.pointerId);
  });

  n.addEventListener('pointerup', e=>{
    if(draggingNode === n){
      try{ n.releasePointerCapture(e.pointerId); }catch(_){}
      draggingNode = null;
     
    }
  });

  /* double-click opens rich text editor (Quill modal) */
  n.addEventListener('dblclick', e=>{
    if(e.target.classList.contains('connector')) return;
    openEditor(n);
    e.stopPropagation();
  });

  /* connector drag-to-connect */
  const connector = n.querySelector('.connector');
  connector.addEventListener('pointerdown', e=>{
    e.stopPropagation();
    startTempEdge(n, e);
  });

  return n;
}

/* selectNode(n)
   ‚Äî node select ‡¥ö‡µÜ‡¥Ø‡µç‡¥Ø‡µÅ‡¥ï; inspector values set ‡¥ö‡µÜ‡¥Ø‡µç‡¥Ø‡µÅ‡¥ï */
function selectNode(n){
  // deselect edge
  if(selectedEdge){ selectedEdge.classList.remove('selected'); selectedEdge=null; }
  if(selectedNode) selectedNode.classList.remove('selected');
  selectedNode = n;
  if(n) n.classList.add('selected');
  if(n){
    document.getElementById('inBg').value = rgbToHex(n.style.background || '#ffffff');
    document.getElementById('inBorder').value = rgbToHex(n.style.borderColor || '#2c7be5');
    document.getElementById('inSize').value = parseInt((n.style.fontSize || '14px'));
  }
}

/* ============================
   Edges (connections)
   ============================ */

/* connect(fromEl, toEl, optType)
   ‚Äî two nodes connect ‡¥ö‡µÜ‡¥Ø‡µç‡¥Ø‡µÅ‡¥ï; edgeType ('child'|'sibling') set ‡¥ö‡µÜ‡¥Ø‡µç‡¥Ø‡¥æ‡¥Ç.
   ‚Äî edgeType ‡¥Ö‡¥®‡µÅ‡¥∏‡¥∞‡¥ø‡¥ö‡µç‡¥ö‡µç stroke class ‡¥ö‡µá‡µº‡¥ï‡µç‡¥ï‡µÅ‡¥®‡µç‡¥®‡µÅ. */
function connect(fromEl, toEl, optType){
  if(fromEl===toEl) return;
  if(edges.some(e=> e.fromEl===fromEl && e.toEl===toEl )) return;
  const line = document.createElementNS('http://www.w3.org/2000/svg','line');
  line.setAttribute('fill', 'none');
  line.setAttribute('stroke-linecap', 'round');
  const edgeType = optType || (toEl._type === 'sibling' || fromEl._type === 'sibling' ? 'sibling' : 'child');
  line.classList.add('edge-line', edgeType);
  edgesSVG.appendChild(line);
  edges.push({line, fromEl, toEl, edgeType});
  line.addEventListener('click', (e)=>{ e.stopPropagation(); selectEdge(line); });
  updateEdges();
}

/* selectEdge(lineEl)
   ‚Äî edge select ‡¥ö‡µÜ‡¥Ø‡µç‡¥Ø‡µÅ‡¥®‡µç‡¥®‡¥§‡µç; node selection clear ‡¥ö‡µÜ‡¥Ø‡µç‡¥Ø‡µÅ‡¥®‡µç‡¥®‡µÅ. */
function selectEdge(lineEl){
  if(selectedNode){ selectedNode.classList.remove('selected'); selectedNode=null; }
  if(selectedEdge) selectedEdge.classList.remove('selected');
  selectedEdge = lineEl;
  if(lineEl) lineEl.classList.add('selected');
}

/* updateEdges()
   ‚Äî ‡¥é‡¥≤‡µç‡¥≤‡¥æ edges-‡¥â‡¥Ç position ‡¥í‡¥§‡µç‡¥§‡µÅ ‡¥ö‡µá‡¥∞‡µç‚Äç‡¥ï‡µç‡¥ï‡µÅ‡¥®‡µç‡¥®‡¥§‡µç */
function updateEdges(){
  const svgRect = edgesSVG.getBoundingClientRect();
  edges.forEach(e=>{
    const r1 = e.fromEl.getBoundingClientRect();
    const r2 = e.toEl.getBoundingClientRect();
    const x1 = r1.left + r1.width/2 - svgRect.left;
    const y1 = r1.top  + r1.height/2 - svgRect.top;
    const x2 = r2.left + r2.width/2 - svgRect.left;
    const y2 = r2.top  + r2.height/2 - svgRect.top;
    e.line.setAttribute('x1', x1); e.line.setAttribute('y1', y1);
    e.line.setAttribute('x2', x2); e.line.setAttribute('y2', y2);
  });
  if(tempEdge){
    const svgRect2 = edgesSVG.getBoundingClientRect();
    const r = tempEdge.fromEl.getBoundingClientRect();
    const x1 = r.left + r.width/2 - svgRect2.left;
    const y1 = r.top  + r.height/2 - svgRect2.top;
    const x2 = tempMouse.x - svgRect2.left;
    const y2 = tempMouse.y - svgRect2.top;
    tempEdge.line.setAttribute('x1', x1); tempEdge.line.setAttribute('y1', y1);
    tempEdge.line.setAttribute('x2', x2); tempEdge.line.setAttribute('y2', y2);
    tempEdge.line.setAttribute('stroke','#888'); tempEdge.line.setAttribute('stroke-dasharray','6,4');
    tempEdge.line.setAttribute('fill', 'none');
    tempEdge.line.setAttribute('stroke-linecap', 'round');
  }
}

/* temp edge while dragging from connector */
let tempEdge = null; let tempMouse = {x:0,y:0};
function startTempEdge(fromEl, pointerEvent){
  const line = document.createElementNS('http://www.w3.org/2000/svg','line');
  line.setAttribute('stroke','#888'); line.setAttribute('stroke-dasharray','6,4'); line.setAttribute('stroke-width','10');
  line.setAttribute('fill', 'none');
  line.setAttribute('stroke-linecap', 'round');
  line.style.pointerEvents = 'none'; // temporary line not clickable
  edgesSVG.appendChild(line);
  tempEdge = {line, fromEl};
  function pointerMove(e){
    tempMouse.x = e.clientX;
    tempMouse.y = e.clientY;
    updateEdges();
  }
  function pointerUp(e){
    const el = document.elementFromPoint(e.clientX, e.clientY);
    const node = findAncestorNode(el);
    if(node && node !== fromEl){
      // determine edge type based on node types
      const et = (node._type === 'sibling' || fromEl._type === 'sibling') ? 'sibling' : 'child';
      connect(fromEl, node, et);
    }
    if(line.parentNode) edgesSVG.removeChild(line);
    tempEdge = null;
    window.removeEventListener('pointermove', pointerMove);
    window.removeEventListener('pointerup', pointerUp);
    updateEdges();
  }
  window.addEventListener('pointermove', pointerMove);
  window.addEventListener('pointerup', pointerUp);
}
function findAncestorNode(el){
  while(el && el !== document.body){
    if(el.classList && el.classList.contains('node')) return el;
    el = el.parentNode;
  }
  return null;
}

/* ============================
   Canvas interactions: pan/zoom + node dragging
   ============================ */

/* canvas pointerdown starts pan if background clicked */
let isPanning = false, panStart = {x:0,y:0};
app.addEventListener('pointerdown', (e)=>{
  if(e.target === app || e.target === canvas || e.target === edgesSVG){
    isPanning = true; panStart.x = e.clientX; panStart.y = e.clientY;
    app.style.cursor = 'grabbing';
    // deselect things
    selectNode(null);
    if(selectedEdge){ selectedEdge.classList.remove('selected'); selectedEdge=null; }
  }
});

/* pointermove: handle node dragging (no clamp) or pan */
window.addEventListener('pointermove', (e)=>{
  const appRect = app.getBoundingClientRect();
  if(draggingNode){
    const pointerCanvasX = (e.clientX - appRect.left - panX)/scale;
    const pointerCanvasY = (e.clientY - appRect.top  - panY)/scale;
    const newLeft = pointerCanvasX - dragOffset.x;
    const newTop  = pointerCanvasY - dragOffset.y;
    // NO clamping ‚Äî allow negative left/top etc.
    draggingNode.style.left = newLeft + 'px';
    draggingNode.style.top  = newTop  + 'px';
    updateEdges();
    return;
  }
  if(isPanning){
    const dx = e.clientX - panStart.x;
    const dy = e.clientY - panStart.y;
    panX += dx; panY += dy; panStart.x = e.clientX; panStart.y = e.clientY;
    setTransform();
  }
});

/* pointerup: release dragging/panning */
window.addEventListener('pointerup', (e)=>{
  if(draggingNode){
    try{ draggingNode.releasePointerCapture(e.pointerId); }catch(_){}
    draggingNode = null;
  }
  if(isPanning){ isPanning = false; app.style.cursor = 'grab'; }
});

/* wheel zoom */
app.addEventListener('wheel', (e)=>{
  e.preventDefault();
  const prevScale = scale;
  const delta = -e.deltaY * 0.0015;
  scale = Math.min(2.5, Math.max(0.3, scale * (1 + delta)));
  const mx = e.clientX; const my = e.clientY;
  panX = mx - (mx - panX) * (scale/prevScale);
  panY = my - (my - panY) * (scale/prevScale);
  setTransform();
}, {passive:false});

/* canvas click: ctrl+click creates node; otherwise deselect */
canvas.addEventListener('click', (e)=>{
  if(e.target === canvas){
    if(e.ctrlKey || e.metaKey){
      const appRect = app.getBoundingClientRect();
      const localX = (e.clientX - appRect.left - panX)/scale;
      const localY = (e.clientY - appRect.top - panY)/scale;
      const n = mkNode(localX, localY, 'New Node', 'child');
      selectNode(n);
      setTimeout(()=>updateEdges(), 10);
    } else {
      selectNode(null);
    }
  }
});
edgesSVG.addEventListener('click', (e)=>{
  if(e.target === edgesSVG){
    if(selectedEdge){ selectedEdge.classList.remove('selected'); selectedEdge=null; }
    selectNode(null);
  }
});

/* ============================
   Toolbar actions & special rules
   ============================ */

/* btnAddChild: create child node (connected from selected) */
btnAddChild.addEventListener('click', ()=>{
  if(!selectedNode){ alert('‡¥∏‡µÜ‡¥≤‡¥ï‡µç‡¥ü‡µç ‡¥ö‡µÜ‡¥Ø‡µç‡¥§ ‡¥í‡¥∞‡µÅ Node ‡¥µ‡µá‡¥£‡¥Ç (click)'); return; }
  const px = selectedNode.offsetLeft, py = selectedNode.offsetTop;
  const child = mkNode(px+160, py, 'Child', 'child');
  connect(selectedNode, child, 'child');
  selectNode(child);
  updateEdges();
});

/* btnAddSibling:
   ‚Äî ‡¥™‡µÅ‡¥§‡¥ø‡¥Ø node selected_node-‡¥®‡µç‡¥±‡µÜ parent-‡¥≤‡µç‚Äç‡¥®‡¥ø‡¥®‡µç‡¥®‡µÅ ‡¥â‡¥£‡µç‡¥ü‡¥æ‡¥µ‡¥£‡¥Ç.
   ‚Äî parent ‡¥ï‡¥£‡µç‡¥ü‡µÜ‡¥§‡µç‡¥§‡¥æ‡µª edges array-‡¥Ø‡¥ø‡µΩ incoming edge (fromEl -> selected) first match ‡¥â‡¥™‡¥Ø‡µã‡¥ó‡¥ø‡¥ï‡µç‡¥ï‡µÅ‡¥®‡µç‡¥®‡µÅ.
   ‚Äî parent ‡¥á‡¥≤‡µç‡¥≤‡µÜ‡¥ô‡µç‡¥ï‡¥ø‡¥≤‡µç‚Äç alert ‡¥ï‡¥æ‡¥£‡¥ø‡¥ï‡µç‡¥ï‡µÅ‡¥Ç. */
btnAddSibling.addEventListener('click', ()=>{
  if(!selectedNode){ alert('‡¥∏‡µÜ‡¥≤‡¥ï‡µç‡¥ü‡µç ‡¥ö‡µÜ‡¥Ø‡µç‡¥§ ‡¥í‡¥∞‡µÅ Node ‡¥µ‡µá‡¥£‡¥Ç (click)'); return; }
  // find parent: an edge where toEl === selectedNode
  const incoming = edges.find(e => e.toEl === selectedNode);
  if(!incoming){
    alert('Parent ‡¥ï‡¥£‡µç‡¥ü‡µÜ‡¥§‡µç‡¥§‡¥æ‡¥®‡¥æ‡¥Ø‡¥ø‡¥≤‡µç‡¥≤ ‚Äî sibling ‡¥∏‡µÉ‡¥∑‡µç‡¥ü‡¥ø‡¥ï‡µç‡¥ï‡¥æ‡µª selected node-‡¥®‡µç‡¥±‡µÜ parent ‡¥µ‡µá‡¥£‡¥Ç.');
    return;
  }
  const parent = incoming.fromEl;
  const px = parent.offsetLeft, py = parent.offsetTop;
  const sibling = mkNode(px, py+120, 'Sibling', 'sibling');
  connect(parent, sibling, 'sibling'); // mark edge as sibling type
  selectNode(sibling);
  updateEdges();
});

/* btnDelete:
   ‚Äî first, if an edge selected -> delete that edge only
   ‚Äî else if node selected -> delete node unless node.dataset.nonremovable === 'true'
   ‚Äî connected edges removed */
btnDelete.addEventListener('click', ()=>{
  if(selectedEdge){
    const idx = edges.findIndex(e=>e.line===selectedEdge);
    if(idx>-1){
      if(edges[idx].line.parentNode) edgesSVG.removeChild(edges[idx].line);
      edges.splice(idx,1);
    }
    selectedEdge=null;
    updateEdges();
    return;
  }
  if(!selectedNode){ alert('‡¥í‡¥®‡µç‡¥®‡µç select ‡¥ö‡µÜ‡¥Ø‡µç‡¥Ø‡µÅ‡¥ï'); return; }
  // prevent deleting non-removable (central)
  if(selectedNode.dataset.nonremovable === 'true'){ alert('‡¥à node ‡¥®‡µÄ‡¥ï‡µç‡¥ï‡¥Ç ‡¥ö‡µÜ‡¥Ø‡µç‡¥Ø‡¥æ‡¥®‡¥æ‡¥µ‡¥ø‡¥≤‡µç‡¥≤.'); return; }
  // remove connected edges
  edges = edges.filter(e=>{
    if(e.fromEl === selectedNode || e.toEl === selectedNode){
      if(e.line.parentNode) edgesSVG.removeChild(e.line);
      return false;
    }
    return true;
  });
  if(selectedNode.parentNode) canvas.removeChild(selectedNode);
  nodes = nodes.filter(n=> n !== selectedNode);
  selectedNode = null;
  updateEdges();
});

/* ============================
   Inspector: movable + minimize + apply
   ============================ */

/* Inspector drag (move the panel) */
const inspector = document.getElementById('inspector');
const inspectorHeader = document.getElementById('inspector-header');
let inspectorDragging=false, inspectorOffset={x:0,y:0};
inspectorHeader.addEventListener('mousedown', (e)=>{
  inspectorDragging = true;
  inspectorOffset.x = e.clientX - inspector.offsetLeft;
  inspectorOffset.y = e.clientY - inspector.offsetTop;
  document.body.style.userSelect = 'none';
});
window.addEventListener('mousemove', (e)=>{
  if(inspectorDragging){
    let nx = e.clientX - inspectorOffset.x;
    let ny = e.clientY - inspectorOffset.y;
    nx = Math.max(0, Math.min(window.innerWidth - inspector.offsetWidth, nx));
    ny = Math.max(0, Math.min(window.innerHeight - inspector.offsetHeight, ny));
    inspector.style.left = nx + 'px';
    inspector.style.top = ny + 'px';
    inspector.style.right = 'unset';
  }
});
window.addEventListener('mouseup', ()=>{ inspectorDragging = false; document.body.style.userSelect = ''; });

/* minimize & close buttons */
document.getElementById('inspector-min-btn').addEventListener('click', ()=>{
  inspector.classList.toggle('minimized');
});
document.getElementById('inspector-close-btn').addEventListener('click', ()=>{
  inspector.style.display = 'none';
});

// Inspector toggle button
const btnToggleInspector = document.getElementById('btnToggleInspector');
btnToggleInspector.addEventListener('click', ()=>{
  if(inspector.style.display === 'none'){
    inspector.style.display = 'block';
  } else {
    inspector.style.display = 'none';
  }
});


/* inspector apply */
document.getElementById('btnApply').addEventListener('click', ()=>{
  if(!selectedNode){ alert('‡¥í‡¥∞‡µÅ node select ‡¥ö‡µÜ‡¥Ø‡µç‡¥Ø‡µÅ‡¥ï'); return; }
  selectedNode.style.background = document.getElementById('inBg').value;
  selectedNode.style.borderColor = document.getElementById('inBorder').value;
  selectedNode.style.fontSize = (document.getElementById('inSize').value || 14) + 'px';
  autoResizeNode(selectedNode);
  updateEdges();
});

/* ============================
   Save / Load / Export / Import
   ============================ */

/* Save button functionality (same as previous export) */
const btnSave = document.getElementById('btnSave');
btnSave.addEventListener('click', ()=>{
  const data = exportData();
  const blob = new Blob([JSON.stringify(data, null, 2)], {type:'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); 
  a.href = url; 
  a.download = 'mindmap.json'; 
  a.click(); 
  URL.revokeObjectURL(url);
});

fileImport.addEventListener('change', (e)=>{
  const f = e.target.files[0]; if(!f) return;
  const r = new FileReader();
  r.onload = ()=> {
    try{ const data = JSON.parse(r.result); loadFromData(data); }catch(err){ alert('Invalid JSON file') }
  };
  r.readAsText(f);
});
function exportData(){
  return {
nodes: nodes.map(n=>({
  html: (n.querySelector('.title').innerHTML || '').replace(/right-shape/g, ''),

  x: n.offsetLeft, y: n.offsetTop,
  type: n._type || 'child',
  bg: n.style.background, border: n.style.borderColor, size: n.style.fontSize,
  nonremovable: n.dataset.nonremovable || '',
  lastEdited: n.dataset.lastEdited || ''   // üÜï
}))
,
    edges: edges.map(e=>({
      from: nodes.indexOf(e.fromEl), to: nodes.indexOf(e.toEl), edgeType: e.edgeType || (e.line.classList.contains('sibling') ? 'sibling' : 'child')
    })),
    view: { panX, panY, scale }
  };
}
function loadFromData(data){
  // clear existing
  edges.forEach(e=>{ if(e.line.parentNode) edgesSVG.removeChild(e.line); });
  edges = [];
  nodes.forEach(n=>{ if(n.parentNode) canvas.removeChild(n); });
  nodes = []; selectedNode = null; selectedEdge = null;

  (data.nodes||[]).forEach(nd=> {
    const n = mkNode(nd.x || 100, nd.y || 100, nd.html || 'Node', nd.type || 'child');

    // üö´ unwanted class remove
    n.classList.remove('right-shape');
    n.querySelector('.title').classList.remove('right-shape');

    if(nd.bg) n.style.background = nd.bg;
    if(nd.border) n.style.borderColor = nd.border;
    if(nd.size) n.style.fontSize = nd.size;
    if(nd.nonremovable) n.dataset.nonremovable = nd.nonremovable;
if(nd.lastEdited){
  n.dataset.lastEdited = nd.lastEdited;
  n.querySelector('.timestamp').textContent = "Last Edited: " + nd.lastEdited;
}



    autoResizeNode(n);
  });
  (data.edges||[]).forEach(ed=>{
    const a = nodes[ed.from], b = nodes[ed.to];
    if(a && b) connect(a, b, ed.edgeType || undefined);
  });
  if(data.view){ panX = data.view.panX||0; panY = data.view.panY||0; scale = data.view.scale||1; setTransform(); }
  updateEdges();
}

/* ============================
   Node Text Editor (Rich text) with Ribbon UI
   ============================ */
const editorModal = document.getElementById('editorModal');
const editorBox = document.getElementById('editorBox');
const editorTitleBar = document.getElementById('editorTitleBar');
const editorCloseBtn = document.getElementById('editorCloseBtn');
const editorTabs = document.getElementById('editorTabs');
const editorToolbarHome = document.getElementById('editorToolbarHome');
const editorToolbarInsert = document.getElementById('editorToolbarInsert');
const editorContent = document.getElementById('editorContent');
const editorSaveBtn = document.getElementById('editorSaveBtn');
let quill = null;
let editingNode = null;

// ‚úÖ CUSTOM VIDEO HANDLER (Same as before)
const videoHandler = () => {
  const url = prompt('Enter YouTube or Vimeo URL:');
  if (!url) return;

  let embedUrl = '';
  // YouTube: https://www.youtube.com/watch?v=VIDEO_ID
  if (url.includes('youtube.com/watch?v=')) {
    const match = url.match(/[?&]v=([^&#]*)/);
    if (match && match[1]) embedUrl = `https://www.youtube.com/embed/${match[1]}`;
  }
  // Short YouTube: https://youtu.be/VIDEO_ID  
  else if (url.includes('youtu.be/')) {
    const id = url.split('youtu.be/')[1]?.split(/[?&#]/)[0];
    if (id) embedUrl = `https://www.youtube.com/embed/${id}`;
  }
  // Vimeo: https://vimeo.com/VIDEO_ID  
  else if (url.includes('vimeo.com/')) {
    const id = url.split('vimeo.com/')[1]?.split(/[?&#]/)[0];
    if (id) embedUrl = `https://player.vimeo.com/video/${id}`;
  }

  if (embedUrl && quill) {
    const range = quill.getSelection();
    if (range) {
      const iframeHtml = `<iframe src="${embedUrl}" width="500" height="300" frameborder="0" allowfullscreen></iframe>`;
      quill.clipboard.dangerouslyPasteHTML(range.index, iframeHtml);
      quill.setSelection(range.index + 1);
    }
  } else {
    alert('Please enter a valid YouTube or Vimeo URL.');
  }
};

/* Tab switching logic */
function switchTab(tabName) {
  // Update tab buttons
  document.querySelectorAll('.editorTab').forEach(tab => {
    tab.classList.remove('active');
  });
  document.querySelector(`.editorTab[data-tab="${tabName}"]`).classList.add('active');

  // Update toolbars
  editorToolbarHome.classList.remove('active');
  editorToolbarInsert.classList.remove('active');
  if (tabName === 'home') {
    editorToolbarHome.classList.add('active');
  } else if (tabName === 'insert') {
    editorToolbarInsert.classList.add('active');
  }
}

// Initialize tabs
document.querySelectorAll('.editorTab').forEach(tab => {
  tab.addEventListener('click', (e) => {
    switchTab(e.target.dataset.tab);
  });
});

/* openEditor(node)
   ‚Äî Node Text Editor modal open ‡¥ö‡µÜ‡¥Ø‡µç‡¥Ø‡µÅ‡¥ï; ‡¥±‡¥ø‡¥ö‡µç‡¥ö‡µç ‡¥ü‡µÜ‡¥ï‡µç‡¥∏‡µç‡¥±‡µç‡¥±‡µç load ‡¥ö‡µÜ‡¥Ø‡µç‡¥Ø‡µÅ‡¥ï */
function openEditor(node){
  editingNode = node;
  if(!quill){
    quill = new Quill('#editor', { 
      theme: 'snow',
      modules: { 
        toolbar: false // Disable default toolbar
      }
    });

    // Bind custom video button
    document.getElementById('insertVideo').addEventListener('click', videoHandler);

    // Bind other insert buttons (for now, just show alerts, you can implement actual functionality)
    document.getElementById('insertPicture').addEventListener('click', () => {
      alert('Insert Picture functionality not implemented yet.');
    });
    document.getElementById('insertShapes').addEventListener('click', () => {
      alert('Insert Shapes functionality not implemented yet.');
    });
    document.getElementById('insertIcons').addEventListener('click', () => {
      alert('Insert Icons functionality not implemented yet.');
    });
    document.getElementById('insertTable').addEventListener('click', () => {
      alert('Insert Table functionality not implemented yet.');
    });

    // Bind Home tab buttons to Quill
    document.querySelectorAll('.ql-bold, .ql-italic, .ql-underline, .ql-strike, .ql-color, .ql-background, .ql-script, .ql-align, .ql-list, .ql-indent, .ql-clean').forEach(btn => {
      btn.addEventListener('click', () => {
        const className = btn.className.split(' ')[1]; // Get the Quill format class
        if (className) {
          const format = className.replace('ql-', '');
          if (format === 'script') {
            quill.format('script', btn.value);
          } else if (format === 'list') {
            quill.format('list', btn.value);
          } else if (format === 'indent') {
            quill.format('indent', btn.value);
          } else if (format === 'align') {
            quill.format('align', btn.value);
          } else if (format === 'color' || format === 'background') {
            // For color/background, you might need to prompt for value or use a color picker
            const color = prompt(`Enter ${format} color (e.g., #ff0000):`);
            if (color) {
              quill.format(format, color);
            }
          } else {
            quill.format(format, true);
          }
        }
      });
    });

    // Bind Font and Size dropdowns
    document.getElementById('fontFamily').addEventListener('change', (e) => {
      quill.format('font', e.target.value);
    });
    document.getElementById('fontSize').addEventListener('change', (e) => {
      quill.format('size', e.target.value);
    });
  }

  quill.root.innerHTML = node.querySelector('.title').innerHTML || '';
  editorModal.style.display = 'flex';
}

// Close button
editorCloseBtn.addEventListener('click', closeEditor);

// Save button
editorSaveBtn.addEventListener('click', ()=>{
  if(editingNode && quill){
    editingNode.querySelector('.title').innerHTML = quill.root.innerHTML || 'Node';

    // üïí timestamp ‡¥ö‡µá‡µº‡¥ï‡µç‡¥ï‡µÅ‡¥®‡µç‡¥®‡µÅ
    const ts = new Date().toLocaleString('en-GB', { 
      day: '2-digit', month: '2-digit', year: 'numeric',
      hour: '2-digit', minute: '2-digit', hour12: true 
    });
    editingNode.dataset.lastEdited = ts;
    editingNode.querySelector('.timestamp').textContent = "Last Edited: " + ts;

    autoResizeNode(editingNode);
    updateEdges();
  }
  closeEditor();
});

function closeEditor(){ 
  editorModal.style.display='none'; 
  editingNode=null; 
}

/* ============================
   Keyboard Delete for Selected Edge
   ============================ */
window.addEventListener('keydown', (e)=>{
  // Prevent if inside input, textarea, or Quill editor
  if(e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.classList.contains('ql-editor')){
    return;
  }

  if(e.key === 'Delete' || e.key === 'Backspace'){
    // If an edge is selected, delete it
    if(selectedEdge){
      btnDelete.click(); // Reuse existing delete logic
      e.preventDefault(); // Prevent browser back (for Backspace)
    }
    // If a node is selected, also handled by btnDelete.click() above
    else if(selectedNode){
      btnDelete.click();
    }
  }
});

/* ============================
   Initialization
   ============================ */
/* create initial central node (non-deletable) */
const central = mkNode(420, 160, '<b>Central Idea</b>', 'central');
selectNode(central);
setTransform();
window.addEventListener('resize', ()=> updateEdges());

</script>

</body>
</html>
